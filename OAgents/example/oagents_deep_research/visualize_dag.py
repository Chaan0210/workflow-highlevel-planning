#!/usr/bin/env python
"""
DAG Visualization Tool for GAIA Benchmark Subtasks
Visualizes the DAG structure generated by --subtask planning
"""

import argparse
import json
import re
import matplotlib.pyplot as plt
import networkx as nx
from typing import Dict, List, Tuple, Any
# pandas import removed - not used
from pathlib import Path
import textwrap

def parse_dag_from_plan(plan_content: str) -> Tuple[List[Tuple[str, str]], List[str], Dict[str, Dict[str, str]]]:
    """
    Parse DAG structure from plan content
    
    Returns:
        dag_list: List of dependencies (ST_A, ST_B) where ST_B depends on ST_A
        parallel_list: List of subtasks that can start immediately
        subtask_dict: Dictionary of subtask details {ST1: {title: ..., steps: ...}}
    """
    dag_list = []
    parallel_list = []
    subtask_dict = {}
    
    # Parse DAG_LIST
    dag_section = re.search(r'##DAG_LIST\n(.*?)(?=##|\Z)', plan_content, re.DOTALL)
    if dag_section:
        dag_content = dag_section.group(1).strip()
        # Extract tuples like (ST1, ST3), (ST1, ST4), (ST2, ST4)
        dag_matches = re.findall(r'\((\w+),\s*(\w+)\)', dag_content)
        dag_list = [(match[0], match[1]) for match in dag_matches]
    
    # Parse PARALLEL_LIST
    parallel_section = re.search(r'##PARALLEL_LIST\n([^\n#]+)', plan_content)
    if parallel_section:
        parallel_content = parallel_section.group(1).strip()
        parallel_list = [x.strip() for x in parallel_content.split(',')]
    
    # Parse Subtasks
    pattern = r'##(ST\d+):(.*?)(?=\n##ST|\Z)'
    for match in re.finditer(pattern, plan_content, re.DOTALL):
        st_code = match.group(1)
        content = match.group(2).strip()
        
        lines = content.split('\n')
        title = lines[0].strip() if lines else ""
        steps = []
        
        for line in lines[1:]:
            if re.match(r'^\d+\.', line.strip()):
                steps.append(line.strip())
        
        subtask_dict[st_code] = {
            "title": title,
            "steps": '\n'.join(steps)
        }
    
    return dag_list, parallel_list, subtask_dict

def create_dag_graph(dag_list: List[Tuple[str, str]], parallel_list: List[str], 
                     subtask_dict: Dict[str, Dict[str, str]]) -> nx.DiGraph:
    """Create NetworkX DiGraph from DAG structure"""
    G = nx.DiGraph()
    
    # Add all subtasks as nodes
    for st_code, details in subtask_dict.items():
        G.add_node(st_code, 
                   title=details["title"][:30] + "..." if len(details["title"]) > 30 else details["title"],
                   steps=details["steps"],
                   is_parallel=st_code in parallel_list)
    
    # Add dependencies as edges
    for source, target in dag_list:
        if source in subtask_dict and target in subtask_dict:
            G.add_edge(source, target)
    
    return G

def visualize_dag(G: nx.DiGraph, question: str, output_path: str = None):
    """Visualize the DAG using matplotlib and networkx"""
    plt.figure(figsize=(16, 12))
    
    # Create layout
    try:
        pos = nx.nx_agraph.graphviz_layout(G, prog='dot')
    except:
        # Fallback to spring layout if graphviz is not available
        pos = nx.spring_layout(G, k=3, iterations=50)
    
    # Separate parallel and dependent nodes
    parallel_nodes = [node for node in G.nodes() if G.nodes[node].get('is_parallel', False)]
    dependent_nodes = [node for node in G.nodes() if not G.nodes[node].get('is_parallel', False)]
    
    # Draw nodes
    nx.draw_networkx_nodes(G, pos, nodelist=parallel_nodes, 
                          node_color='lightgreen', node_size=3000, alpha=0.8)
    nx.draw_networkx_nodes(G, pos, nodelist=dependent_nodes, 
                          node_color='lightblue', node_size=3000, alpha=0.8)
    
    # Draw edges
    nx.draw_networkx_edges(G, pos, edge_color='gray', arrows=True, 
                          arrowsize=20, arrowstyle='->', width=2)
    
    # Draw labels
    labels = {}
    for node in G.nodes():
        title = G.nodes[node].get('title', node)
        labels[node] = f"{node}\n{title}"
    
    nx.draw_networkx_labels(G, pos, labels, font_size=8, font_weight='bold')
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='lightgreen', 
                   markersize=15, label='Parallel Tasks (can start immediately)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='lightblue', 
                   markersize=15, label='Dependent Tasks (wait for prerequisites)')
    ]
    plt.legend(handles=legend_elements, loc='upper left')
    
    # Add title
    wrapped_question = textwrap.fill(question, width=80)
    plt.title(f"DAG Structure for GAIA Question:\n{wrapped_question}", 
              fontsize=14, fontweight='bold', pad=20)
    
    plt.axis('off')
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"DAG visualization saved to: {output_path}")
    
    plt.show()

def print_dag_analysis(G: nx.DiGraph, dag_list: List[Tuple[str, str]], 
                       parallel_list: List[str], subtask_dict: Dict[str, Dict[str, str]]):
    """Print detailed DAG analysis"""
    print("\n" + "="*80)
    print("DAG STRUCTURE ANALYSIS")
    print("="*80)
    
    print(f"\nüìä Graph Statistics:")
    print(f"   ‚Ä¢ Total Subtasks: {G.number_of_nodes()}")
    print(f"   ‚Ä¢ Dependencies: {G.number_of_edges()}")
    print(f"   ‚Ä¢ Parallel Tasks: {len(parallel_list)}")
    print(f"   ‚Ä¢ Dependent Tasks: {G.number_of_nodes() - len(parallel_list)}")
    
    print(f"\nüöÄ Parallel Execution (can start immediately):")
    for st in parallel_list:
        if st in subtask_dict:
            print(f"   ‚Ä¢ {st}: {subtask_dict[st]['title']}")
    
    print(f"\nüîó Dependencies:")
    for source, target in dag_list:
        source_title = subtask_dict.get(source, {}).get('title', 'Unknown')
        target_title = subtask_dict.get(target, {}).get('title', 'Unknown')
        print(f"   ‚Ä¢ {target} depends on {source}")
        print(f"     ‚îî‚îÄ \"{target_title}\" waits for \"{source_title}\"")
    
    print(f"\nüìã Subtask Details:")
    for st_code, details in subtask_dict.items():
        is_parallel = "üü¢ PARALLEL" if st_code in parallel_list else "üîµ DEPENDENT"
        print(f"\n   {st_code} ({is_parallel}):")
        print(f"   Title: {details['title']}")
        if details['steps']:
            steps = details['steps'].split('\n')[:3]  # Show first 3 steps
            for i, step in enumerate(steps):
                print(f"   {step}")
            total_steps = len(details['steps'].split('\n'))
            if total_steps > 3:
                remaining_steps = total_steps - 3
                print(f"   ... (and {remaining_steps} more steps)")

def load_gaia_results(results_file: str) -> List[Dict[str, Any]]:
    """Load GAIA results from JSONL file"""
    results = []
    if Path(results_file).exists():
        with open(results_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip():
                    results.append(json.loads(line.strip()))
    return results

def find_subtask_plans(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Find results that contain subtask planning"""
    subtask_results = []
    
    for result in results:
        intermediate_steps = result.get('intermediate_steps', [])
        for step in intermediate_steps:
            if step.get('step_type') == 'planning':
                plan_content = step.get('plan', '')
                # Check for subtask planning indicators
                if '##DAG_LIST' in plan_content and '##PARALLEL_LIST' in plan_content:
                    subtask_results.append({
                        'task_id': result.get('task_id'),
                        'question': result.get('question'), 
                        'plan_content': plan_content,
                        'result': result,
                        'agent_name': result.get('agent_name', 'Unknown'),
                        'true_answer': result.get('true_answer', ''),
                        'prediction': result.get('prediction', ''),
                        'start_time': result.get('start_time', ''),
                        'end_time': result.get('end_time', '')
                    })
                    break
    
    return subtask_results

def main():
    parser = argparse.ArgumentParser(description="Visualize DAG structure from GAIA subtask planning")
    parser.add_argument("--results_file", type=str, required=True,
                       help="Path to GAIA results JSONL file")
    parser.add_argument("--task_id", type=str, 
                       help="Specific task ID to visualize (if not provided, shows all)")
    parser.add_argument("--output_dir", type=str, default="dag_visualizations",
                       help="Output directory for visualizations")
    parser.add_argument("--show_analysis", action="store_true", default=True,
                       help="Show detailed DAG analysis")
    
    args = parser.parse_args()
    
    # Create output directory
    output_dir = Path(args.output_dir)
    output_dir.mkdir(exist_ok=True)
    
    # Load results
    print(f"Loading GAIA results from: {args.results_file}")
    results = load_gaia_results(args.results_file)
    print(f"Loaded {len(results)} results")
    
    # Find subtask plans
    subtask_results = find_subtask_plans(results)
    print(f"Found {len(subtask_results)} results with subtask planning")
    
    if not subtask_results:
        print("‚ùå No subtask planning found in the results!")
        print("   Make sure you ran GAIA with --subtask flag")
        return
    
    # Filter by task_id if specified
    if args.task_id:
        subtask_results = [r for r in subtask_results if r['task_id'] == args.task_id]
        if not subtask_results:
            print(f"‚ùå No subtask planning found for task_id: {args.task_id}")
            return
    
    # Process each subtask result
    for i, subtask_result in enumerate(subtask_results):
        task_id = subtask_result['task_id']
        question = subtask_result['question']
        plan_content = subtask_result['plan_content']
        
        print(f"\n{'='*80}")
        print(f"PROCESSING TASK {i+1}/{len(subtask_results)}: {task_id}")
        print(f"{'='*80}")
        print(f"Question: {textwrap.fill(question, width=70)}")
        
        # Print additional metadata
        if 'agent_name' in subtask_result:
            print(f"Agent: {subtask_result['agent_name']}")
        if 'start_time' in subtask_result and subtask_result['start_time']:
            print(f"Processing Time: {subtask_result['start_time']} - {subtask_result.get('end_time', 'N/A')}")
        if subtask_result.get('prediction'):
            print(f"Prediction: {textwrap.fill(str(subtask_result['prediction'])[:100] + '...', width=70)}")
        if subtask_result.get('true_answer'):  
            print(f"True Answer: {textwrap.fill(str(subtask_result['true_answer'])[:100] + '...', width=70)}")
        
        try:
            # Parse DAG structure
            dag_list, parallel_list, subtask_dict = parse_dag_from_plan(plan_content)
            
            if not subtask_dict:
                print(f"‚ùå No valid subtask structure found for task {task_id}")
                continue
            
            # Create graph
            G = create_dag_graph(dag_list, parallel_list, subtask_dict)
            
            # Show analysis
            if args.show_analysis:
                print_dag_analysis(G, dag_list, parallel_list, subtask_dict)
            
            # Visualize
            output_path = output_dir / f"dag_{task_id}.png"
            visualize_dag(G, question, str(output_path))
            
        except Exception as e:
            print(f"‚ùå Error processing task {task_id}: {e}")
            continue
    
    print(f"\n‚úÖ Visualization complete! Check {output_dir} for saved images.")

if __name__ == "__main__":
    main()